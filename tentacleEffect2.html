<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Эксперименты с толщиной щупалец VYRUS</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background-color: #111827;
            color: #e5e7eb;
            margin: 0;
            padding: 20px;
            line-height: 1.6;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        h1, h2 {
            color: #fbbf24;
            text-align: center;
        }
        .section {
            background-color: #1f2937;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid #374151;
        }
        .code-block {
            background-color: #111827;
            border-radius: 4px;
            padding: 15px;
            margin: 10px 0;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            border: 1px solid #374151;
        }
        .highlight {
            background-color: #374151;
            padding: 2px 4px;
            border-radius: 3px;
        }
        .variable {
            color: #f87171;
        }
        .function {
            color: #60a5fa;
        }
        .comment {
            color: #a3a3a3;
        }
        .canvas-container {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }
        canvas {
            border: 1px solid #374151;
            background-color: #0f172a;
        }
        .timeline {
            display: flex;
            justify-content: space-between;
            margin: 30px 0;
            position: relative;
        }
        .timeline::before {
            content: '';
            position: absolute;
            top: 20px;
            left: 0;
            right: 0;
            height: 4px;
            background: #374151;
            z-index: 1;
        }
        .timeline-point {
            position: relative;
            text-align: center;
            z-index: 2;
            background: #1f2937;
            padding: 10px;
            border-radius: 8px;
            width: 120px;
        }
        .timeline-label {
            font-size: 12px;
            color: #9ca3af;
        }
        .legend {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 20px;
            margin: 20px 0;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .color-box {
            width: 20px;
            height: 20px;
            border-radius: 3px;
        }
        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        input[type="range"] {
            width: 200px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Эксперименты с толщиной щупалец VYRUS</h1>
        
        <div class="section">
            <h2>Обзор</h2>
            <p>Этот файл позволяет экспериментировать с различной толщиной щупалец в игре VYRUS. Щупальца представляют собой визуальные эффекты, показывающие попытки вирусов захватить вражеские клетки.</p>
            
            <div class="legend">
                <div class="legend-item">
                    <div class="color-box" style="background: #EF4444;"></div>
                    <span>Игрок 1 (Красный)</span>
                </div>
                <div class="legend-item">
                    <div class="color-box" style="background: #3B82F6;"></div>
                    <span>Игрок 2 (Синий)</span>
                </div>
                <div class="legend-item">
                    <div class="color-box" style="background: #10B981;"></div>
                    <span>Игрок 3 (Зеленый)</span>
                </div>
                <div class="legend-item">
                    <div class="color-box" style="background: #F59E0B;"></div>
                    <span>Игрок 4 (Желтый)</span>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>Управление толщиной щупалец</h2>
            <div class="controls">
                <div class="control-group">
                    <label for="minThickness">Минимальная толщина:</label>
                    <input type="range" id="minThickness" min="0.5" max="5" step="0.1" value="1.5">
                    <span id="minThicknessValue">1.5</span>
                </div>

                <div class="control-group">
                    <label for="maxThickness">Максимальная толщина:</label>
                    <input type="range" id="maxThickness" min="1" max="10" step="0.1" value="4">
                    <span id="maxThicknessValue">4</span>
                </div>

                <div class="control-group">
                    <label for="thicknessVariation">Вариация толщины:</label>
                    <input type="range" id="thicknessVariation" min="0" max="1" step="0.01" value="0.3">
                    <span id="thicknessVariationValue">0.3</span>
                </div>

                <div class="control-group">
                    <label for="progressEffect">Влияние прогресса:</label>
                    <input type="range" id="progressEffect" min="0" max="2" step="0.1" value="0.5">
                    <span id="progressEffectValue">0.5</span>
                </div>

                <div class="control-group">
                    <label for="startThickness">Толщина в начальной точке (x1, x2):</label>
                    <input type="range" id="startThickness" min="1" max="30" step="1" value="15">
                    <span id="startThicknessValue">15</span>
                </div>

                <div class="control-group">
                    <label for="endThickness">Толщина в конечной точке (y1, y2):</label>
                    <input type="range" id="endThickness" min="0.5" max="10" step="0.1" value="2">
                    <span id="endThicknessValue">2</span>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>Визуализация щупалец с разной толщиной</h2>
            <div class="canvas-container">
                <canvas id="tentacleEffectCanvas" width="600" height="400"></canvas>
            </div>
        </div>

        <div class="section">
            <h2>Реализация кода с изменяемой толщиной</h2>
            <p>Вот как можно изменять толщину щупалец в зависимости от различных факторов:</p>
            <div class="code-block">
                // === ЩУПАЛЬЦА С ИЗМЕНЯЕМОЙ ТОЛЩИНОЙ ===<br>
                if (gameState.gameState === 'battle') {<br>
                &nbsp;&nbsp;const visibleTentacles = gameState.tentacles.filter(tentacle => {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;const startX = offsetX + tentacle.from.col * cellWidth + cellWidth / 2;<br>
                &nbsp;&nbsp;&nbsp;&nbsp;const startY = offsetY + tentacle.from.row * cellHeight + cellHeight / 2;<br>
                &nbsp;&nbsp;&nbsp;&nbsp;const endX = offsetX + tentacle.to.col * cellWidth + cellWidth / 2;<br>
                &nbsp;&nbsp;&nbsp;&nbsp;const endY = offsetY + tentacle.to.row * cellHeight + cellHeight / 2;<br>
                &nbsp;&nbsp;&nbsp;&nbsp;const padding = 50;<br>
                &nbsp;&nbsp;&nbsp;&nbsp;return (<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(startX >= -padding && startX <= displayWidth + padding && startY >= -padding && startY <= displayHeight + padding) ||<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(endX >= -padding && endX <= displayWidth + padding && endY >= -padding && endY <= displayHeight + padding)<br>
                &nbsp;&nbsp;&nbsp;&nbsp;);<br>
                &nbsp;&nbsp;});<br><br>
                
                &nbsp;&nbsp;const tentaclesToDraw = Math.min(<br>
                &nbsp;&nbsp;&nbsp;&nbsp;visibleTentacles.length,<br>
                &nbsp;&nbsp;&nbsp;&nbsp;visualEffectQuality === 'high' ? 100 : visualEffectQuality === 'medium' ? 50 : 20<br>
                &nbsp;&nbsp;);<br><br>
                
                &nbsp;&nbsp;for (let i = 0; i < tentaclesToDraw; i++) {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;const tentacle = visibleTentacles[i];<br>
                &nbsp;&nbsp;&nbsp;&nbsp;const startX = offsetX + tentacle.from.col * cellWidth + cellWidth / 2;<br>
                &nbsp;&nbsp;&nbsp;&nbsp;const startY = offsetY + tentacle.from.row * cellHeight + cellHeight / 2;<br>
                &nbsp;&nbsp;&nbsp;&nbsp;const endX = offsetX + tentacle.to.col * cellWidth + cellWidth / 2;<br>
                &nbsp;&nbsp;&nbsp;&nbsp;const endY = offsetY + tentacle.to.row * cellHeight + cellHeight / 2;<br><br>
                
                &nbsp;&nbsp;&nbsp;&nbsp;// Рассчитываем толщину щупальца на основе различных факторов<br>
                &nbsp;&nbsp;&nbsp;&nbsp;const baseThickness = 1.5; // Базовая толщина<br>
                &nbsp;&nbsp;&nbsp;&nbsp;const progressFactor = 1 + tentacle.progress * 0.5; // Увеличение толщины с прогрессом<br>
                &nbsp;&nbsp;&nbsp;&nbsp;const distanceFactor = Math.min(2, Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2)) / 100); // Влияние расстояния<br>
                &nbsp;&nbsp;&nbsp;&nbsp;const variation = (Math.random() - 0.5) * 0.4; // Случайная вариация<br>
                &nbsp;&nbsp;&nbsp;&nbsp;const thickness = Math.max(0.5, baseThickness * progressFactor * distanceFactor + variation);<br><br>
                
                &nbsp;&nbsp;&nbsp;&nbsp;ctx.beginPath();<br>
                &nbsp;&nbsp;&nbsp;&nbsp;ctx.moveTo(startX, startY);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;ctx.lineTo(endX, endY);<br><br>
                
                &nbsp;&nbsp;&nbsp;&nbsp;const playerColor = gameState.players[tentacle.owner]?.color || '#FFFFFF';<br>
                &nbsp;&nbsp;&nbsp;&nbsp;const rgbColor = hexToRgb(playerColor);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;if (rgbColor) {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const alpha = Math.min(1, 0.3 + tentacle.progress * 0.7);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx.strokeStyle = `rgba(${rgbColor.r}, ${rgbColor.g}, ${rgbColor.b}, ${alpha})`;<br>
                &nbsp;&nbsp;&nbsp;&nbsp;} else {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx.strokeStyle = `rgba(255, 255, 255, 0.5)`;<br>
                &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                &nbsp;&nbsp;&nbsp;&nbsp;ctx.lineWidth = thickness;<br>
                &nbsp;&nbsp;&nbsp;&nbsp;ctx.stroke();<br><br>
                
                &nbsp;&nbsp;&nbsp;&nbsp;if (tentacle.progress > 0.7) {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const pulseFactor = Math.sin(Date.now() * 0.005) * 0.5 + 0.5;<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const tipRadius = 3 + 4 * pulseFactor;<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx.beginPath();<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx.arc(endX, endY, tipRadius, 0, 2 * Math.PI);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx.fillStyle = playerColor;<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx.globalAlpha = 0.7;<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx.fill();<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx.globalAlpha = 1;<br>
                &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                &nbsp;&nbsp;}<br>
                }
            </div>
        </div>
    </div>

    <script>
        // Анимация для визуализации эффекта щупальца с изменяемой толщиной
        const canvas = document.getElementById('tentacleEffectCanvas');
        const ctx = canvas.getContext('2d');
        
        // Устанавливаем размеры холста в соответствии с его размером отображения
        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;
        
        // Получаем элементы управления
        const minThicknessSlider = document.getElementById('minThickness');
        const maxThicknessSlider = document.getElementById('maxThickness');
        const thicknessVariationSlider = document.getElementById('thicknessVariation');
        const progressEffectSlider = document.getElementById('progressEffect');
        const startThicknessSlider = document.getElementById('startThickness');
        const endThicknessSlider = document.getElementById('endThickness');

        const minThicknessValue = document.getElementById('minThicknessValue');
        const maxThicknessValue = document.getElementById('maxThicknessValue');
        const thicknessVariationValue = document.getElementById('thicknessVariationValue');
        const progressEffectValue = document.getElementById('progressEffectValue');
        const startThicknessValue = document.getElementById('startThicknessValue');
        const endThicknessValue = document.getElementById('endThicknessValue');

        // Инициализируем значения
        minThicknessValue.textContent = minThicknessSlider.value;
        maxThicknessValue.textContent = maxThicknessSlider.value;
        thicknessVariationValue.textContent = thicknessVariationSlider.value;
        progressEffectValue.textContent = progressEffectSlider.value;
        startThicknessValue.textContent = startThicknessSlider.value;
        endThicknessValue.textContent = endThicknessSlider.value;

        // Обработчики событий для слайдеров
        minThicknessSlider.addEventListener('input', function() {
            minThicknessValue.textContent = this.value;
        });

        maxThicknessSlider.addEventListener('input', function() {
            maxThicknessValue.textContent = this.value;
        });

        thicknessVariationSlider.addEventListener('input', function() {
            thicknessVariationValue.textContent = this.value;
        });

        progressEffectSlider.addEventListener('input', function() {
            progressEffectValue.textContent = this.value;
        });

        startThicknessSlider.addEventListener('input', function() {
            startThicknessValue.textContent = this.value;
        });

        endThicknessSlider.addEventListener('input', function() {
            endThicknessValue.textContent = this.value;
        });
        
        let animationProgress = 0;
        
        // Генерируем случайные контрольные точки для изогнутого пути
        function generateControlPoints(startX, startY, endX, endY) {
            // Вычисляем середину
            const midX = (startX + endX) / 2;
            const midY = (startY + endY) / 2;
            
            // Создаем случайное смещение для контрольных точек
            const offsetRange = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2)) * 0.3;
            
            // Генерируем 2 контрольные точки со случайными смещениями
            const ctrlX1 = midX + (Math.random() - 0.5) * offsetRange;
            const ctrlY1 = midY + (Math.random() - 0.5) * offsetRange;
            
            const ctrlX2 = midX + (Math.random() - 0.5) * offsetRange;
            const ctrlY2 = midY + (Math.random() - 0.5) * offsetRange;
            
            return [{x: ctrlX1, y: ctrlY1}, {x: ctrlX2, y: ctrlY2}];
        }
        
        // Сохраняем контрольные точки
        let controlPoints = generateControlPoints(
            canvas.width / 3, 
            canvas.height / 2, 
            2 * canvas.width / 3, 
            canvas.height / 2
        );
        
        // Функция получения точки вдоль кубической кривой Безье
        function getBezierPoint(t, start, cp1, cp2, end) {
            const u = 1 - t;
            const tt = t * t;
            const uu = u * u;
            const uuu = uu * u;
            const ttt = tt * t;
            
            let x = uuu * start.x;
            x += 3 * uu * t * cp1.x;
            x += 3 * u * tt * cp2.x;
            x += ttt * end.x;
            
            let y = uuu * start.y;
            y += 3 * uu * t * cp1.y;
            y += 3 * u * tt * cp2.y;
            y += ttt * end.y;
            
            return {x, y};
        }
        
        function drawTentacleEffect() {
            // Очищаем холст
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Рисуем фоновую сетку
            ctx.strokeStyle = '#374151';
            ctx.lineWidth = 1;
            for (let x = 0; x <= canvas.width; x += 40) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= canvas.height; y += 40) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Рисуем клетки вирусов
            const startX = canvas.width / 3;
            const startY = canvas.height / 2;
            const staticEndX = 2 * canvas.width / 3; // Статическая конечная позиция
            const staticEndY = canvas.height / 2; // Статическая конечная позиция

            // Рисуем исходную клетку вируса
            ctx.beginPath();
            ctx.arc(startX, startY, 15, 0, Math.PI * 2);
            ctx.fillStyle = '#EF4444'; // Красный вирус
            ctx.fill();
            ctx.strokeStyle = '#374151';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Рисуем целевую клетку вируса
            ctx.beginPath();
            ctx.arc(staticEndX, staticEndY, 15, 0, Math.PI * 2);
            ctx.fillStyle = '#3B82F6'; // Синий вирус
            ctx.fill();
            ctx.strokeStyle = '#374151';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Вычисляем свойства щупальца
            const progress = Math.min(1, animationProgress);

            // Получаем значения из слайдеров
            const minThickness = parseFloat(minThicknessSlider.value);
            const maxThickness = parseFloat(maxThicknessSlider.value);
            const thicknessVariation = parseFloat(thicknessVariationSlider.value);
            const progressEffect = parseFloat(progressEffectSlider.value);
            const startThicknessValue = parseFloat(startThicknessSlider.value);
            const endThicknessValue = parseFloat(endThicknessSlider.value);

            // Рассчитываем толщину щупальца на основе различных факторов
            const baseThickness = minThickness;
            const progressFactor = 1 + progress * progressEffect; // Влияние прогресса на толщину
            const distanceFactor = Math.min(2, Math.sqrt(Math.pow(staticEndX - startX, 2) + Math.pow(staticEndY - startY, 2)) / 100); // Влияние расстояния
            const variation = (Math.random() - 0.5) * thicknessVariation * 2; // Случайная вариация
            const thickness = Math.max(minThickness, Math.min(maxThickness, baseThickness * progressFactor * distanceFactor + variation));

            // Вычисляем непредсказуемую конечную точку (как сигнал кардиомонитора)
            const ecgMovementAmplitude = 20; // Амплитуда движения как у ЭКГ
            const ecgMovementFrequency = 0.005; // Частота движения как у ЭКГ (медленнее)
            const flyX = staticEndX + Math.sin(Date.now() * ecgMovementFrequency) * ecgMovementAmplitude + Math.sin(Date.now() * ecgMovementFrequency * 2.3) * ecgMovementAmplitude * 0.3;
            const flyY = staticEndY + Math.cos(Date.now() * ecgMovementFrequency * 1.7) * ecgMovementAmplitude + Math.cos(Date.now() * ecgMovementFrequency * 3.1) * ecgMovementAmplitude * 0.2;

            // Генерируем случайные контрольные точки для изогнутого пути
            const start = {x: startX, y: startY};
            const end = {x: flyX, y: flyY};

            // Генерируем контрольные точки для пути (без случайности для более плавного движения)
            // Используем фиксированные смещения, чтобы избежать дрожания
            const cp1 = {
                x: startX + (flyX - startX) * 0.3,
                y: startY + (flyY - startY) * 0.3
            };
            const cp2 = {
                x: startX + (flyX - startX) * 0.6,
                y: startY + (flyY - startY) * 0.6
            };

            // Рисуем щупальце как набор соединенных сегментов с плавным изменением толщины
            const segments = 100; // Большое количество сегментов для плавности
            const points = [];

            // Создаем массив точек щупальца
            for (let i = 0; i <= segments * progress; i++) {
                const t = i / segments;
                const point = getBezierPoint(t, start, cp1, cp2, end);
                points.push(point);
            }

            // Рисуем щупальце с градиентной толщиной от тонкого кончика к широкому основанию
            if (points.length > 1) {
                // Рисуем щупальце как набор сегментов с плавным изменением толщины
                for (let i = 0; i < points.length - 1; i++) {
                    const currentPoint = points[i];
                    const nextPoint = points[i + 1];

                    // Рассчитываем прогресс для текущего сегмента (0 = кончик, 1 = основание)
                    const segmentProgress = i / (points.length - 1);

                    // Рассчитываем толщину: от начальной толщины к конечной толщине
                    const segmentThickness = startThicknessValue + (endThicknessValue - startThicknessValue) * segmentProgress;

                    // Рассчитываем прозрачность: более прозрачная на конце, менее прозрачная у основания
                    const alpha = Math.min(1, 0.3 + segmentProgress * 0.7);

                    ctx.beginPath();
                    ctx.moveTo(currentPoint.x, currentPoint.y);
                    ctx.lineTo(nextPoint.x, nextPoint.y);
                    ctx.strokeStyle = `rgba(239, 68, 68, ${alpha})`;
                    ctx.lineWidth = segmentThickness;
                    ctx.stroke();
                }
            }

            // Рисуем пульсирующий кончик, если прогресс достаточно высок
            if (progress > 0.7) {
                const pulseFactor = Math.sin(Date.now() * 0.005) * 0.5 + 0.5;
                // Используем толщину конечной точки для радиуса кончика
                const tipRadius = (endThicknessValue / 2) + 3 * pulseFactor;

                ctx.beginPath();
                ctx.arc(flyX, flyY, tipRadius, 0, 2 * Math.PI);
                ctx.fillStyle = '#EF4444'; // Красный
                ctx.globalAlpha = 0.8; // Увеличили непрозрачность кончика
                ctx.fill();
                ctx.globalAlpha = 1;
            }

            // Обновляем прогресс анимации
            animationProgress += 0.005;

            // Сброс при достижении конца и генерация новых контрольных точек
            if (animationProgress > 1.2) {
                animationProgress = 0;
            }
            
            // Продолжаем анимацию
            requestAnimationFrame(drawTentacleEffect);
        }
        
        // Запускаем анимацию
        drawTentacleEffect();
    </script>
</body>
</html>